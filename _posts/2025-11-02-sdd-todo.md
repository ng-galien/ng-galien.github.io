---
layout: post
lang: fr
title: "TODO State Model ‚Äî Du SQL √† Neo4j"
description: "√âtude de cas progressive : comment une simple TODO list devient un mod√®le d'√©tats vivant (State‚ÄëDriven Design) et se parcourt en graphe."
date: 2025-11-02 20:00:00 +0100
last_modified_at: 2025-11-08 12:55:00 +0100
author: Alexandre Boyer
categories: [Architecture]
tags: [State-Driven Design, Graph-Driven Design, SDD, GDD, Neo4j, ArchitectureLogicielle, DataModeling, DDD]
permalink: /2025/11/02/sdd-todo/
page_id: sdd-todo
nav_section: articles
toc: true
mermaid: true
---

{:.lead}
‚úÖ Du SQL √† Neo4j : quand la TODO list devient un mod√®le d'√©tats vivant.

> _Note de refonte (GDD ‚Üí SDD)_ : Le terme ¬´ Graph‚ÄëDriven Design ¬ª est remplac√© par **State‚ÄëDriven Design (SDD)** pour mettre l‚Äôaccent sur la mod√©lisation explicite des **√©tats** et **transitions** append‚Äëonly. Le graphe illustre une impl√©mentation de parcours.
>
> **S√©rie SDD** : [Intro](/2025/11/01/gdd-intro/) ‚Ä¢ [Fondations](/2025/11/01/gdd/) ‚Ä¢ [Axiomes](/2025/11/08/gdd-core/) ‚Ä¢ [SQL E‚Äëcommerce](/2025/11/02/gdd-solves/) ‚Ä¢ [TODO Neo4j](/2025/11/02/gdd-todo/)

> **Ta TODO list d‚Äôhier a 12 colonnes et 3 migrations.**
> **Celle de demain ? Un graphe/journal qui grandit sans douleur.**
> _Et c‚Äôest pr√©cis√©ment l√† que le State‚ÄëDriven Design (SDD) montre sa force._

## 1. üéØ Objectif initial

Cr√©er une simple application de TODO list.

**User Story 1 :**

> En tant qu‚Äôutilisateur, je veux cr√©er une t√¢che et la marquer comme termin√©e.

### Mod√®le initial (SQL)

```sql
CREATE TABLE todo (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255),
  is_done BOOLEAN DEFAULT false
);
```

Simple, efficace... jusqu‚Äô√† la premi√®re √©volution.

---

## 2. üß± Premi√®re √©volution : l‚Äôaffectation

**User Story 2 :**

> En tant qu‚Äôutilisateur, je veux assigner une t√¢che √† quelqu‚Äôun.

Dans un mod√®le SQL classique, on ajoute une cl√© √©trang√®re :

```sql
ALTER TABLE todo ADD COLUMN assigned_user_id BIGINT REFERENCES user(id);
```

Et c‚Äôest le d√©but de la fin : les colonnes se multiplient.

### En SDD / Neo4j ‚Äî affectation

```cypher
CREATE (alex:User {name:"Alexandre"}),
       (task:Task {title:"√âcrire l‚Äôarticle"});
// Cr√©ation de la t√¢che
CREATE (alex)-[:CREATED {at:datetime("2025-11-02T09:00:00")}]->(task);
// Affectation de la t√¢che
CREATE (alex)-[:ASSIGNED_TO {at:datetime("2025-11-02T09:05:00"), role:"owner", source:"ui"}]->(task);
```

> Le graphe d√©crit la r√©alit√© : _quelqu‚Äôun a cr√©√© quelque chose._

---

## 3. üï∏Ô∏è Deuxi√®me √©volution : les transitions d‚Äô√©tat

**User Story 3 :**

> En tant qu‚Äôutilisateur, je veux suivre l‚Äô√©tat d‚Äôune t√¢che : ‚Äú√† faire‚Äù, ‚Äúen
> cours‚Äù, ‚Äútermin√©e‚Äù.

Dans SQL, on ajoute :

```sql
ALTER TABLE todo ADD COLUMN status ENUM('TODO','DOING','DONE');
```

#### SQL bien fait : historisation minimale

```sql
-- SQL "bien fait" : historisation des statuts
CREATE TABLE task_status_log (
  task_id BIGINT REFERENCES todo(id),
  status VARCHAR(10) CHECK (status IN ('TODO','DOING','DONE')),
  changed_at TIMESTAMP NOT NULL DEFAULT now(),
  changed_by BIGINT REFERENCES user(id)
);
```

M√™me en version soign√©e, tu dupliques de la logique, tu relies plusieurs tables,
et tu perds la **s√©mantique du verbe** (qui a _STARTED_, qui a _MARKED_DONE_).

Mais ces √©tats s‚Äô√©crasent dans le temps : impossible de savoir _quand_ ils ont
chang√©.

### En SDD / Neo4j ‚Äî transitions

```cypher
MATCH (a:User {name:"Alexandre"}), (t:Task {title:"√âcrire l‚Äôarticle"})
CREATE (a)-[:STARTED {at:datetime("2025-11-02T09:15:00"), channel:"web"}]->(t);
CREATE (a)-[:MARKED_DONE {at:datetime("2025-11-02T10:30:00"), outcome:"ok"}]->(t);
```

> Les transitions deviennent des relations dat√©es.  
> Tu obtiens l‚Äôhistorique complet **sans table de log**.

> üí° **Note ‚Äî statut courant : d√©riv√© vs mat√©rialis√©**  
> Par d√©faut, on **d√©rive** le statut depuis les relations d‚Äô√©v√©nements (plus
> fid√®le au m√©tier).  
> Pour des lectures intensives, on peut **mat√©rialiser** un `t.status` (voir ¬ß
> _8.5 Read model_).

---

## 4. üß© Troisi√®me √©volution : les d√©pendances

**User Story 4 :**

> Une t√¢che ne peut √™tre termin√©e que si une autre est d√©j√† faite.

En SQL :

```sql
CREATE TABLE todo_dependencies (
  task_id BIGINT REFERENCES todo(id),
  depends_on_id BIGINT REFERENCES todo(id)
);
```

### En Neo4j ‚Äî d√©pendances

```cypher
MATCH (t1:Task {title:"√âcrire l‚Äôarticle"}), (t2:Task {title:"Publier le post"})
CREATE (t2)-[:DEPENDS_ON {kind:"hard", minLag:duration("P0D"), rationale:"Publication apr√®s relecture"}]->(t1);
```

üëâ **Convention claire** : `t2-[:DEPENDS_ON]->t1` signifie que **t2 ne peut
avancer que si t1 est termin√©e**.

> Le lien logique _est_ la donn√©e.  
> Pas besoin de red√©finir ton sch√©ma.

---

## 5. üí¨ Quatri√®me √©volution : les commentaires

**User Story 5 :**

> En tant qu‚Äôutilisateur, je veux commenter une t√¢che.

En SQL :

```sql
CREATE TABLE comment (
  id SERIAL,
  todo_id BIGINT,
  user_id BIGINT,
  text TEXT,
  created_at TIMESTAMP
);
```

### En Neo4j ‚Äî commentaires

```cypher
MATCH (t:Task {title:"√âcrire l‚Äôarticle"})
MERGE (m:User {name:"Magali"})
CREATE (m)-[:COMMENTED {
  at: datetime("2025-11-02T11:00:00"),
  text: "Super intro !",
  source: "ui",
  edited: false
}]->(t);
```

> Les commentaires deviennent une **relation porteuse de texte** (pas besoin de
> n≈ìud `Comment`).

---

## 6. üß† Cinqui√®me √©volution : les projets

**User Story 6 :**

> Les t√¢ches doivent √™tre regroup√©es dans des projets.

En SQL :

```sql
ALTER TABLE todo ADD COLUMN project_id BIGINT REFERENCES project(id);
```

### En Neo4j ‚Äî projets

```cypher
CREATE (p:Project {name:"Blog GDD"})
MATCH (t1:Task {title:"√âcrire l‚Äôarticle"}), (t2:Task {title:"Publier le post"})
CREATE (p)-[:CONTAINS {since:datetime("2025-11-02T08:30:00"), rank:1}]->(t1),
       (p)-[:CONTAINS {since:datetime("2025-11-02T08:35:00"), rank:2}]->(t2);
```

> Tu ajoutes un nouveau n≈ìud et des liens.  
> Pas une seule migration.

---

## 7. üß¨ Mod√®le complet

```mermaid
graph TD
  P["üìÅ Project: Blog GDD"]
  T1["üìù Task: √âcrire l‚Äôarticle"]
  T2["üì¢ Task: Publier le post"]
  U1["üë§ Alexandre"]
  U2["üë§ Magali"]

  P -->|CONTAINS {since:08:30, rank:1}| T1
  P -->|CONTAINS {since:08:35, rank:2}| T2

  U1 -->|CREATED {at:09:00}| T1
  U1 -->|STARTED {at:09:15}| T1
  U2 -->|ASSIGNED_TO {at:09:20, role:owner}| T1
  U2 -->|MARKED_DONE {at:10:30}| T1
  T2 -->|DEPENDS_ON {kind:hard}| T1
  U2 -->|COMMENTED {at:11:00, text:'Super intro !'}| T1
```

## 7.5 üîß Relations enrichies (SDD orient√© graphe)

Dans le **State‚ÄëDriven Design (SDD)**, la **relation porte la s√©mantique**¬†: ce ne
sont pas que des liens, ce sont des **√©v√©nements** ou des **contraintes** avec
des attributs.

- **Temporalit√©**¬†: `at`, `since`, `until`, `minLag` (latence minimale entre
  t√¢ches).
- **S√©mantique**¬†: `kind:"hard|soft"`, `role:"owner|reviewer"`, `rationale`.
- **Ordonnancement**¬†: `rank` pour un backlog par projet.
- **Provenance**¬†: `source:"ui|api"`, `channel:"web|mobile"`, `outcome`.
- **Flags**¬†: `active:true/false` pour l‚Äôaffectation courante.
- **Commentaires** : relation `COMMENTED {text, at, source, edited}` contenant
  le message complet.

**Exemples de requ√™tes qui exploitent ces propri√©t√©s¬†:**

```cypher
// Backlog du projet ordonn√© par priorit√© (rank)
MATCH (p:Project {name:"Blog GDD"})-[r:CONTAINS]->(t:Task)
RETURN t.title, r.rank
ORDER BY r.rank ASC;

// D√©pendances strictes (kind='hard') d'une t√¢che
MATCH (t:Task {title:"Publier le post"})- [d:DEPENDS_ON {kind:"hard"}]->(prereq:Task)
RETURN prereq.title, d.rationale;
```

---

## 8. üîç Requ√™tes Cypher expressives

### T√¢ches avec d√©pendances

```cypher
MATCH (t2:Task)-[:DEPENDS_ON]->(t1:Task)
RETURN t2.title AS task, t1.title AS depends_on;
```

## 8.5 üß± Read model / mat√©rialisation pour les lectures

Quand les lectures priment, on peut mat√©rialiser une vue rapide du statut
courant.

```cypher
// Vue mat√©rialis√©e "simple" du statut courant
MATCH (t:Task)
OPTIONAL MATCH (t)<-[d:MARKED_DONE]-()
WITH t, d
SET t.status = CASE WHEN d IS NULL THEN 'Pending' ELSE 'DONE' END,
    t.done_at = d.at;
```

**SQL (√©quivalent)**¬†: vue mat√©rialis√©e pour consolider le statut.

```sql
-- SQL : materialized view pour le statut courant
CREATE MATERIALIZED VIEW task_current AS
SELECT t.id,
       t.title,
       COALESCE( (SELECT max(changed_at)
                  FROM task_status_log l
                  WHERE l.task_id = t.id
                    AND l.status = 'DONE'), NULL) AS done_at,
       CASE WHEN EXISTS (
           SELECT 1 FROM task_status_log l
           WHERE l.task_id = t.id AND l.status = 'DONE'
       ) THEN 'DONE' ELSE 'Pending' END AS status
FROM todo t;
-- REFRESH MATERIALIZED VIEW task_current;  -- √† planifier
```

### Historique d‚Äôune t√¢che

```cypher
MATCH (t:Task {title:"√âcrire l‚Äôarticle"})<-[r]-(u)
RETURN type(r) AS action, u.name, r.at, r.text
ORDER BY r.at;
```

### Progression d‚Äôun projet

```cypher
MATCH (p:Project {name:"Blog GDD"})-[:CONTAINS]->(t:Task)
OPTIONAL MATCH (t)<-[done:MARKED_DONE]-()
RETURN t.title, CASE WHEN done IS NULL THEN 'Pending' ELSE 'Done' END AS status;
```

### Commentaires d‚Äôune t√¢che

```cypher
MATCH (u:User)-[c:COMMENTED]->(t:Task {title:"√âcrire l‚Äôarticle"})
RETURN u.name, c.at, c.text, c.source, c.edited
ORDER BY c.at;
```

### Affectation active (flag sur la relation)

```cypher
MATCH (t:Task {title:"√âcrire l‚Äôarticle"})<- [a:ASSIGNED_TO]- (u:User)
WHERE coalesce(a.active, true) = true
RETURN u.name, a.at, a.role, a.source;
```

---

## 9. ‚öñÔ∏è Comparatif d‚Äô√©volutivit√©

| √âvolution                                   | SQL                                                       | Neo4j (GDD)                                    | Co√ªt cognitif                                                           |
| ------------------------------------------- | --------------------------------------------------------- | ---------------------------------------------- | ----------------------------------------------------------------------- |
| Ajout d‚Äôun concept (Comment, Project, etc.) | Migration + JOINS                                         | Nouveau n≈ìud + lien                            | **Faible** si &lt; 5 types de relations ; **gagne** apr√®s 3+ √©volutions |
| Historisation                               | Table log + triggers (ou audit)                           | Relations √©v√©nementielles natives              | **Moyen** (multiplication des tables en SQL)                            |
| D√©pendances                                 | Table de jointure + contraintes anti-cycles (non trivial) | Relation `DEPENDS_ON` + parcours               | **Moyen‚Üí√âlev√©** en SQL ; **Faible** en graphe                           |
| Workflow m√©tier                             | Enums + triggers + proc√©dures                             | Relations temporelles + r√®gles Cypher/Triggers | **Moyen** dans les deux, mais plus **lisible** en graphe                |
| Lisibilit√©                                  | Structure fig√©e                                           | Narration naturelle                            | **Faible‚ÜíMoyen** (apprentissage Cypher)                                 |

_R√®gle pratique_ : pour un **CRUD simple et stable**, SQL fait le job.  
D√®s que tu as **‚â• 3 √©volutions** ou **‚â• 5 types de relations**, le graphe prend
l‚Äôavantage.

## 9.5 ‚ö° Micro‚Äëbenchmark (exemple illustratif)

> Tests sur un dataset jouet (~1‚ÄØ000 t√¢ches / 2‚ÄØ500 relations).  
> √Ä prendre comme **ordre de grandeur**, pas comme v√©rit√© absolue.

| Op√©ration                          | SQL (JOINs)        | Cypher              |
| ---------------------------------- | ------------------ | ------------------- |
| ¬´ T√¢ches qui d√©pendent de X ¬ª      | ~4 JOINs ‚Üí ~120‚ÄØms | 1 traversal ‚Üí ~8‚ÄØms |
| ¬´ Historique complet d‚Äôune t√¢che ¬ª | ~3 tables ‚Üí ~80‚ÄØms | 1 MATCH ‚Üí ~5‚ÄØms     |

---

## 10. üß™ Cas r√©els o√π la mono‚Äëtable d√©g√©n√®re

Voici **4 sc√©narios** concrets o√π une mod√©lisation mono‚Äëtable (statuts,
bool√©ens, champs optionnels) devient vite fragile ‚Äî et comment le **Graph‚ÄëDriven
Design** simplifie.

### 10.1 Commande e‚Äëcommerce (paiements, exp√©ditions, retours)

#### Mono‚Äëtable qui gonfle

```sql
orders(
  id, customer_id, total,
  status ENUM('PENDING','PAID','PACKED','SHIPPED','DELIVERED','RETURNED','REFUNDED'),
  is_paid BOOLEAN, is_shipped BOOLEAN, is_returned BOOLEAN, is_refunded BOOLEAN,
  cancel_reason, cancelled_at,
  shipped_at, delivered_at,
  refund_amount, refunded_at,
  tracking_number, carrier,
  return_authorized_at, return_received_at
);
```

#### Pourquoi √ßa casse

- Statuts + bool√©ens qui **se contredisent**.
- **Multiplicit√©** cach√©e (exp√©ditions partielles, paiements multiples).
- **Colonnes optionnelles** √† gogo (nulls).

#### SDD minimal

```mermaid
graph TD
  O[Order] -->|PAID {at, amount}| P(Payment)
  O -->|SHIPPED {at, tracking}| S(Shipment)
  S -->|DELIVERED {at}| D(Facility)
  O -->|RETURNED {at, qty}| R(Return)
  R -->|REFUNDED {at, amount}| P2(Payment)
```

#### Requ√™tes m√©tier ‚Äî e‚Äëcommerce

```cypher
// Combien d'exp√©ditions ?
MATCH (:Order {id:$id})-[:SHIPPED]->(s:Shipment) RETURN count(s);
// Statut courant d√©riv√©
MATCH (o:Order {id:$id})<-[e:PAID|SHIPPED|DELIVERED|RETURNED|REFUNDED]-()
RETURN head(collect(type(e) ORDER BY e.at DESC)) AS current_status;
```

---

### 10.2 Ticket / Incident (assignations, escalades, SLA)

#### Mono‚Äëtable (ticket)

```sql
tickets(
  id, title, description,
  status ENUM('OPEN','IN_PROGRESS','PENDING','RESOLVED','CLOSED'),
  assigned_user_id, assigned_team_id,
  is_escalated BOOLEAN, escalated_at,
  priority ENUM('P1','P2','P3'),
  sla_breach_at, customer_visible BOOLEAN,
  duplicate_of_id, relates_to_id, blocked_by_id
);
```

#### Pourquoi √ßa casse

- **Polymorphismes** bricol√©s (FK optionnelles).
- **R√©p√©titions temporelles** (r√©ouvertures, escalades).
- M√©lange **√©tat courant** / **historique**.

#### SDD minimal

```mermaid
graph TD
  T[Ticket] <-->|ASSIGNED_TO {at, active}| U(User)
  SLA(SLA) -->|BREACHED {at}| T
  T -->|BLOCKED_BY| T2(Ticket)
  U2(User) -->|CHANGED_STATUS {from,to,at}| T
```

#### Requ√™tes ‚Äî ticket

```cypher
// Assignation active
MATCH (t:Ticket {id:$id})<-[a:ASSIGNED_TO]-(u:User)
WHERE coalesce(a.active,true) RETURN u.name;
// Chemin de blocage
MATCH p = (t:Ticket {id:$id})-[:BLOCKED_BY*1..4]->(root)
RETURN nodes(p) LIMIT 1;
```

---

### 10.3 Abonnement & facturation (essais, pauses, √©checs de paiement)

#### Mono‚Äëtable (abonnement)

```sql
subscriptions(
  id, account_id, plan_id,
  status ENUM('TRIAL','ACTIVE','PAST_DUE','CANCELLED','PAUSED'),
  trial_end_at, cancel_at, paused_from, paused_to,
  last_payment_failed BOOLEAN, failure_reason,
  next_invoice_at, current_period_end,
  upgraded_from_plan_id, downgraded_to_plan_id
);
```

#### Pourquoi √ßa casse

- **P√©riodes** multiples (trial/pause) ‚â† colonnes scalaires.
- **√âv√©nements de paiement** multiples (tentatives, √©checs).
- **Changements de plan** non lin√©aires.

#### SDD minimal

```mermaid
graph TD
  S(Subscription) -->|TRIAL {from,to}| P1(Period)
  S -->|PAUSED {from,to}| P2(Period)
  S -->|BILLS| I(Invoice)
  PA(PaymentAttempt) -->|FOR {at, outcome}| I
  S -->|CHANGED_PLAN {at, from, to}| PL(Plan)
```

#### Requ√™tes ‚Äî abonnement

```cypher
// Tentatives √©chou√©es sur la derni√®re facture
MATCH (s:Subscription {id:$id})-[:BILLS]->(i:Invoice)<-[:FOR {outcome:"failed"}]-(p:PaymentAttempt)
RETURN count(p);
```

---

### 10.4 Workflow √©ditorial (versions, reviews, publication planifi√©e)

#### Mono‚Äëtable (workflow)

```sql
articles(
  id, title, body,
  status ENUM('DRAFT','IN_REVIEW','APPROVED','SCHEDULED','PUBLISHED','RETRACTED'),
  is_featured BOOLEAN, scheduled_at, published_at, retracted_at,
  reviewer_id, approver_id, reason, version_number,
  asset1_url, asset2_url
);
```

#### Pourquoi √ßa casse

- Les **versions** ne sont pas une simple colonne.
- Les **transitions** sont multiples (review/approve/schedule/publish/retract).
- Les **assets** sont multiples et √©volutifs.

#### SDD minimal

```mermaid
graph TD
  A(Article) -->|HAS_VERSION n| V(Version)
  U1(User) -->|REVIEWED {at, outcome}| V
  U2(User) -->|APPROVED {at}| V
  V -->|SCHEDULED {at}| PB(Publication)
  PB -->|PUBLISHED {at}| CH(Channel)
  V -->|USES| AS(Asset)
```

**Requ√™te**

```cypher
// Derni√®re version approuv√©e non publi√©e
MATCH (a:Article {id:$id})-[:HAS_VERSION]->(v)
WHERE NOT EXISTS { (v)-[:PUBLISHED]->() }
  AND EXISTS { (:User)-[:APPROVED]->(v) }
RETURN v ORDER BY v.n DESC LIMIT 1;
```

---

## 11. üß≠ En r√©sum√©

> Chaque User Story a enrichi le mod√®le **sans jamais casser le pr√©c√©dent**.  
> Le graphe s‚Äô√©tend comme une toile vivante : chaque relation ajoute du sens.
>
> Le **State‚ÄëDriven Design** permet d‚Äôavoir une vision fluide du m√©tier,  
> sans migrations ni refactoring permanent.

---

## 12. üöÄ Pour aller plus loin

Tu peux lancer ce mod√®le localement avec Neo4j via Docker :

```yaml
version: "3.9"
services:
  neo4j:
    image: neo4j:5
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
    volumes:
      - ./neo4j-data:/data
```

Puis ouvre [http://localhost:7474](http://localhost:7474)  
et ex√©cute les scripts `cypher` de cet article.

---

## 13. üß© Prochain article

> _Les n≈ìuds canoniques et la stabilit√© des domaines :  
> comment identifier les √©l√©ments immuables dans un graphe m√©tier._

## 14. üéÆ Call‚Äëto‚Äëaction

> **Et toi ?**  
> Colle ton `schema.sql` le plus moche en commentaire.  
> Je te montre en 3 lignes Cypher comment le rendre √©volutif.  
> _(Promis, pas de jugement.)_
