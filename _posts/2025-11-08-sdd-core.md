---
layout: post
lang: fr
title: "Modéliser les états : 20 axiomes cœur et réalisation SQL"
description: "Axiomes sémantiques et principes de réalisation SQL pour un modèle State‑Driven centré sur états, transitions explicites et append‑only."
date: 2025-11-08 00:00:00 +0100
last_modified_at: 2025-11-08 09:56:00 +0100
author: Alexandre Boyer
categories: [Architecture]
tags: [sdd, state-driven design, data modeling, domain-driven design, ddd, sql, architecture]
permalink: /2025/11/08/sdd-core/
page_id: article-sdd-core
nav_section: articles
toc: true
---

{:.lead}
Ce document condense les principes structurants pour modéliser des **états métier** stables et dérivables, avec des **transitions explicites** et une **traçabilité append‑only**. Il prolonge l'introduction publiée dans [l’article introductif](/2025/11/01/sdd-intro/) et complète la vue d’ensemble présentée dans [Des tables fourre-tout aux relations fonctionnelles](/2025/11/01/sdd/).

> **Série SDD** : [Intro](/2025/11/01/sdd-intro/) • [Fondations](/2025/11/01/sdd/) • [Axiomes](/2025/11/08/sdd-core/) • [SQL E‑commerce](/2025/11/02/sdd-solves/) • [TODO Neo4j](/2025/11/02/sdd-todo/)

## A. Axiomes cœur (sémantique)

1. **Monodomaine** – Un schéma d’état ne porte qu’un métier (un seul ADT). Mélanger des métiers viole le modèle.
2. **État dérivable** – Un état est entièrement déterminé par ses données. Aucun “status magique” n’est nécessaire pour le déduire.
3. **Optionnels non-décisionnels** – Une valeur optionnelle n’altère jamais l’appartenance à l’état ; elle n’enrichit que sa description.
4. **Temporalité explicite** – Tout état existe sur un intervalle (implicite via le journal ou explicite via [from,to)). Sans temporalité → ce n’est pas un état, mais une caractéristique.
5. **Transitions premières classes** – Un changement d’état est une transition explicite, pas une mutation en place.
6. **Unicité d’état actif** – À un instant t, pour une entité donnée et un domaine donné, un seul état peut être actif.
7. **Append-only** – L’historique ne se réécrit pas : on clôt l’ancien état, on insère le nouveau.
8. **Variants porteurs** – Les variantes de l’ADT portent leurs attributs propres et leurs invariants. L’énum “à champs identiques” est un anti‑pattern.
9. **Reconstructibilité** – À partir de la donnée stockée, on peut rejouer l’histoire des états et retrouver la vue à une date passée.
10. **Composition par lecture** – Les vues “globales” se composent (projections/joins) ; on ne fusionne pas les domaines dans une même table.

## B. Axiomes réalisation SQL (structure)

1. **Journal canonique** – Chaque ADT possède un journal ordonné (version/timestamp) qui enregistre les transitions (append‑only).
2. **Tête déterministe** – L’état courant est le dernier enregistrement du journal (ordre total par order_id + version/created_at).
3. **Intégrité forte des variants** – Deux approches : (a) journal monolithique : une colonne FK par variant + CHECK num_nonnulls = 1 ; (b) pivot + payloads : pivot commun + relation 1–1 vers table payload spécifique.
4. **Unicité d’intervalle** – Si les durées sont matérialisées, pas de recouvrement pour (entity, domaine).
5. **Transitions autorisées** – Le graphe des transitions est déclaré (table allowed_transition) et contrôlé (contrainte/trigger déferré).
6. **Cohérence transactionnelle** – Fermeture de l’état précédent et insertion du nouveau se font atomiquement dans une même transaction.
7. **Pointeur local** – Tout pointeur de lecture est par domaine/ADT, reconstructible depuis le journal ; jamais global partagé.
8. **Évolutivité sans casse** – Ajouter un variant ne casse pas l’historique : colonne + FK + CHECK (monolithique) ou nouvelle table payload (pivot+payloads).
9. **Contrôles différés** – Les contraintes inter‑tables complexes sont déférées au COMMIT pour autoriser une transition complète.
10. **Audit lisible** – Les structures exposent nativement qui / quand / quoi (entité, variant, bornes, version) sans mécanisme externe.

## C. Corollaires (tests rapides)

T1 – Monodomaine ? Le schéma parle-t-il d’un métier unique (sinon scinder).  
T2 – Dérivabilité ? Si je supprime tout champ “status”, puis-je recalculer l’état (sinon incomplet).  
T3 – Optionnels inoffensifs ? Rendre un champ optionnel NULL peut-il changer l’état (si oui : obligatoire ou ADT mal fissionné).  
T4 – Temporalité ? Puis-je répondre “quand cet état a commencé/fini ?” (sinon temporalité manquante).  
T5 – Un seul actif ? Deux états actifs simultanés pour (entité, domaine) existent-ils (si oui : contrainte manquante).  
T6 – Append-only ? L’historique n’est jamais écrasé (sinon violation).  
T7 – Transitions verrouillées ? Une transition hors-graphe est-elle bloquée (sinon modèle poreux).  
T8 – Reconstructibilité ? Puis-je reconstruire la tête et les intervalles depuis le seul journal (sinon dépendance fragile).

## Synthèse

Ces axiomes définissent un cadre : **ADT persistant, mono‑domaine, états dérivables, temporalité maîtrisée, transitions explicites, append‑only** et une réalisation SQL privilégiant intégrité, lisibilité et évolutivité.

### Pour aller plus loin

- Origine du besoin et symptômes du modèle data‑first : [Introduction SDD](/2025/11/01/sdd-intro/)
- Construction relationnelle complète : [Article principal](/2025/11/01/sdd/)

Prochain volet : un guide pratique de migration de schémas legacy vers un journal d’états dérivables (historisation sans casse & invariants).
