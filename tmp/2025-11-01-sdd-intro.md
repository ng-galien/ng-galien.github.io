---
published: false
layout: post
lang: fr
title: "State‑Driven Design : Introduction par les états"
description: Introduction au State‑Driven Design (SDD) et réflexion sur les limites du modèle data‑first.
date: 2025-11-01 08:00:00 +0100
last_modified_at: 2025-11-03 10:00:00 +0100
author: ab
categories: [Architecture]
tags: [
  data modeling,
  state-driven design,
  sdd,
  graph-driven design
  domain-driven design,
  ddd,
  architecture logicielle
]
permalink: /2025/11/01/sdd-intro/
page_id: article-sdd-intro
nav_section: articles
toc: true
---

{:.lead}

> TL;DR :  
> Traditionnellement, la modélisation de données se concentre sur les entités et
> leurs attributs. Les modèles de données traditionnels finissent souvent en
> tables obèses, difficiles à maintenir.
>
> Le State‑Driven Design (SDD) propose de centrer la modélisation non plus sur
> les entités, mais sur les états et transitions, en s’appuyant sur des ADT
> (types algébriques) pour exprimer clairement les variantes et invariants.
>
> Résultat : des données plus stables, une architecture plus souple, et un
> langage métier plus proche de la réalité. {: .prompt-tip }

## Introduction

La modélisation de données est au cœur de tout système d'information, mais les
approches classiques finissent souvent par rigidifier le métier.  
Nous allons examiner une autre voie : déplacer la variabilité vers les
**relations** plutôt que dans les entités, pour obtenir des modèles plus
naturels, évolutifs et fidèles à la réalité métier.

Cet article part du constat du caractère fourre-tout des modèles relationnels et
montre comment une approche inspirée des graphes permet de mieux gérer et
capturer la dynamique et les évolutions du métier.

---

## Le constat du terrain : un réflexe data-first dominant

Un projet logiciel débute souvent par la création de tables de données, le
modèle relationnel étant la norme dominante. La logique métier est ensuite
construite autour d'agrégats de données, souvent sous la forme d'objets
anémiques.

Ce réflexe _data-first_ est intuitif : il donne un point de départ concret,
c'est l'approche la plus communément utilisée dans le monde réel, nous
manipulons des données et elles doivent être stockées quelque part.

Ainsi, lorsqu'un besoin émerge, la première question que l'on se pose est
souvent :

> Qu'est-ce qu'on ajoute dans la table `xxx` ?  
> On va ajouter un booléen `is_xxx` pour la feature, rajouter une 46e valeur à
> l'enum `status`, ou créer un `JSON` pour stocker les données dynamiques. {:
> .prompt-danger }

Bien qu'il existe d'autres approches, comme le Domain-Driven Design (DDD), qui
mettent l'accent sur le métier avant la structure des données, le réflexe
_data-first_ persiste.

Il est souvent renforcé par les outils et frameworks qui favorisent la création
rapide de schémas de données.

### Impacts sur l'évolution du système

Ce réflexe a des conséquences profondes sur la manière dont les systèmes
évoluent.  
Il conduit à une **accumulation de complexité** dans les tables, car chaque
nouvelle exigence métier se traduit par une modification de la structure des
données.

À long terme, cette approche crée un écart entre le métier et le modèle. Les
tables deviennent des archives de compromis : un champ ajouté pour un cas
temporaire, un booléen pour une exception, un JSON pour un besoin pressant.

Le métier n'est plus isolé, mais dilué dans un maelström de colonnes de tables.

Le résultat est une cohérence qui se perd progressivement, où chaque ajout
opacifie le système existant au lieu de le clarifier.

Ce phénomène est amplifié dans les environnements agiles, où les itérations
rapides poussent à des ajustements fréquents.

### Conséquence pour les équipes agiles

Dans le contexte d'équipes agiles, on procède souvent par itérations rapides,
c'est la norme.

Chaque sprint apporte son lot de changements, souvent urgents, et la pression
pour livrer pousse à des solutions rapides.

Le modèle de données, censé être stable, devient un champ de bataille : on
ajoute des colonnes, on modifie des types, on crée des tables temporaires.

Chaque changement devient une opération lourde : migration, tests, refactorings
d'ORM.  
Cette dette structurelle devient un frein à la souplesse, un paradoxe pour un
processus agile.

> Le propos n'est pas de rejeter le principe de l'agilité et de l'approche
> itérative pour revenir aux cycles en V rigides, mais de souligner que la
> structure des données doit être pensée pour accompagner cette agilité, pas la
> freiner.  
> Il faut s'adapter au _data-first_ et à la porosité entre le métier et le
> modèle, plutôt que de lutter contre eux. {: .prompt-info }

---

## Les tables fourre-tout : un legacy qui s'installe

Dans la plupart des systèmes matures, certaines tables deviennent monstrueuses :
**Product**, **Customer**, **Order**.  
Elles débutent simples, puis gonflent avec le temps, jusqu'à accumuler plusieurs
dizaines de colonnes, souvent à moitié nulles.

### Symptômes typiques

- **Nullabilité excessive** : des champs optionnels partout, synonymes
  d'incertitude.
- **Colonnes contradictoires** : `is_deleted` et `active`, coexistant sans règle
  claire.
- **Objets massifs** : entités devenant des sacs de champs optionnels.
- **Couplage diffus** : chaque évolution risque d'en casser d'autres.

### Répercussions sur le code

Dans l'immense majorité des cas, ces tables fourre-tout sont portées par des
objets métiers, le plus souvent anémiques, qui portent l'ensemble des attributs.

Le code applicatif devient un enchevêtrement de règles pour gérer les cas
particuliers, on ne compte plus les conditions if/else pour vérifier la présence
ou l'absence de valeurs.  
Le code s'alourdit à mesure que le modèle se déforme, les principes SOLID ne
sont plus qu'un lointain souvenir.

La maintenance et la correction de bugs deviennent un travail d'archéologie. Les
nouveaux développeurs mettent des semaines à comprendre les relations cachées
entre colonnes et statuts.

La modification d'un champ peut avoir des conséquences imprévues ailleurs dans
le système, l'ajout d'un nouvel état peut nécessiter des ajustements dans
plusieurs services.

> On doit alors se fier à l'expérience et à la mémoire collective, plutôt qu'à
> une structure claire et cohérente. Ne comptez pas sur la documentation pour
> compenser un modèle confus : elle est toujours obsolète ou incomplète. {:
> .prompt-warning }

Face à cette complexité croissante, l'équipe se retrouve en permanence devant le
choix cornélien du Quick & Dirty versus la refactorisation lourde.  
Chaque décision devient un compromis entre livrer rapidement et préserver la
santé du code.

### Tension entre stabilité et évolution

Le dilemme fondamental est celui de la **stabilité** versus l'**évolution**.  
D'un côté, on cherche à garder une base stable, facile à comprendre et à
maintenir.  
De l'autre, le métier évolue, les besoins changent, et le modèle doit
s'adapter.  
Le réflexe _data-first_ pousse à modifier la structure des données pour chaque
nouvelle exigence, mais cela fragilise la stabilité.  
Au final, on se retrouve dans un cercle vicieux : plus on modifie la structure,
plus elle devient instable, et plus il est difficile de l'adapter.

> On doit se libérer de cette tension en repensant la manière dont on modélise
> les données.  
> Existe-t-il une approche qui permette à la fois stabilité et flexibilité ? {:
> .prompt-tip }

---

## Implémentation : modéliser et parcourir via un graphe

Vous avez identifié les symptômes du modèle _data-first_ et ses limites face aux
évolutions métier ?

Dans la [suite de cet article](/2025/11/01/sdd/), nous explorons en profondeur
comment le **State‑Driven Design** permet de :

- Déplacer la variabilité vers des **états** et **transitions** explicites
- Rendre les entités **stables** et l’historique **append‑only**
- Aligner le modèle de données avec le **langage métier** (DDD)
- Implémenter cette approche avec **PostgreSQL** ou **Neo4j**
- Intégrer les relations comme **capacités** dans une API hypermédia
- Migrer progressivement depuis un modèle legacy

→ [Lire la suite : Des tables fourre-tout aux relations fonctionnelles](/2025/11/01/sdd/)

---
