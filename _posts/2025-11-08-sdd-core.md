---
layout: post
lang: fr
title: "Modéliser les états"
description: "Principes de modélisation des objets métier et de leurs états via des ADT."
date: 2025-11-08 00:00:00 +0100
last_modified_at: 2025-11-08 12:15:00 +0100
author: ab
categories: [Architecture]
tags: [sdd, state-driven design, data modeling, domain-driven design, ddd, sql, architecture]
permalink: /2025/11/08/sdd-core/
page_id: article-sdd-core
nav_section: articles
toc: true
---

{:.lead}
Nous allons détailler les principes structurants pour modéliser des **états métier** consistants et évolutifs, avec des **transitions explicites** et sans perte de **traçabilité**.

## ADT (types algébriques de données) : la brique de base

> Dans la grande majorité des cas, un objet métier peut être modélisé comme un ADT d’états, chaque état représentant une *variante* de l’objet avec ses attributs spécifiques.
{:.prompt-tip}

Un **ADT** (Algebraic Data Type) est une structure de données définie par une **somme de variantes** (types disjoints) où chaque variante peut porter ses propres attributs (produit de champs).  

Les ADT sont courants en programmation fonctionnelle (Haskell, OCaml, F#) et se rapprochent des **types discriminés** ou **union types** dans des [les languages de la vie réelle](#adt-dans-les-langages-de-la-vie-réelle).

## Principes fondamentaux

1. **Mono domaine** – Un schéma d’état ne porte qu’un métier (un seul ADT). Mélanger des métiers viole le modèle.
2. **État dérivable** – Un état est entièrement déterminé par ses données. Aucun “status magique” n’est nécessaire pour le déduire.
3. **Optionnels non-décisionnels** – Une valeur optionnelle n’altère jamais l’appartenance à l’état ; elle n’enrichit que sa description.
4. **Temporalité explicite** – Tout état existe sur un intervalle (implicite via le journal ou explicite via [from,to)). Sans temporalité → ce n’est pas un état, mais une caractéristique.
5. **Transitions premières classes** – Un changement d’état est une transition explicite, pas une mutation en place.
6. **Unicité d’état actif** – À un instant t, pour une entité donnée et un domaine donné, un seul état peut être actif.
7. **Append-only** – L’historique ne se réécrit pas : on clôt l’ancien état, on insère le nouveau.
8. **Variants porteurs** – Les variantes de l’ADT portent leurs attributs propres et leurs invariants. L’énum “à champs identiques” est un [anti‑pattern](#enumeration-porteuse-de-létat).
9. **Immutabilité** – Dans la grande majorité des cas, les états une fois créés ne sont jamais modifiés, on a donc tout intérêt à les traiter comme des [objets immuables](#immutabilité).
10. **Reconstructibilité** – À partir de la donnée stockée, on peut rejouer l’histoire des états et retrouver la vue à une date passée.
11. **Composition par lecture** – Les vues “globales” se composent (projections/joins) ; on ne fusionne pas les domaines dans une même table.

## Anti patterns

On retrouve des booléens et des énumérations porteuses d’état dans la majorité des schémas relationnels, souvent à l’origine de problèmes de maintenabilité et d’évolution. Nous détaillons ci‑dessous deux anti‑patterns courants.

### Booléens décisionnels

> Les booléens décisionnels mènent mènent rapidement à des combinaisons ambiguës ou incohérentes.
{: .prompt-tip}

L’usage de booléens pour représenter des états métier est un anti‑pattern fréquent. Un booléen `is_paid` peut sembler simple, mais il ne capture pas la complexité des états possibles (ex. `PENDING`, `PAID`, `CANCELLED`, `REFUNDED`). Il conduit souvent un état ambigu voir incohérent.

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  is_paid BOOLEAN DEFAULT false,
  is_cancelled BOOLEAN DEFAULT false,
  is_refunded BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  modified_at TIMESTAMPTZ DEFAULT now()
);
```

Dans cet exemple :

| Cas | Valeurs possibles | Interprétation |
|-----|-------------------|----------------|
| Ambigu | is_paid = true, is_cancelled = true | Commande payée puis annulée ? |
| Ambigu | is_paid = false, is_refunded = true | Commande remboursée sans paiement ? |
| Incohérent | is_paid = true, is_cancelled = true, is_refunded = true | Commande payée, annulée et remboursée ? |

Ces cas illustrent l’ambiguïté combinatoire : plusieurs flags vrais produisent des combinaisons impossibles à interpréter. Les autres ambiguïtés (temporelle, granularité, domaine croisé) sont détaillées ci‑dessous.

Les booléens de statut simplifient excessivement des situations riches. Quatre ambiguïtés dominantes expliquent la dérive :

1. Combinatoire – Plusieurs flags vrais (`is_paid` + `is_cancelled` + `is_refunded`) forment des combinaisons que le schéma ne sait pas interpréter ni interdire (cf. tableau ci‑dessus).
1. Temporelle – L’ordre des faits est perdu : `is_paid = true` et `is_cancelled = true` ne disent pas lequel est survenu en premier, empêchant toute logique métier fiable.
1. Granularité – Un flag ne porte ni montants, ni raisons, ni distinctions (autorisé vs capturé, partiel vs total). L’état réel a besoin d’attributs structurés.
1. Domaine croisé – Des flags de domaines différents (`is_paid`, `is_shipped`, `is_delivered`) se retrouvent sur la même table ; on autorise implicitement des états illégaux (livré sans payé) faute d’invariants exprimés.

> La table devient une matrice implicite d’états difficile à valider et à rejouer. Remplacer les booléens par un **journal d’événements** ou un **ADT de variantes** rend l’historique explicite, encode les attributs indispensables et formalise les transitions autorisées.
{: .prompt-warning }

### Enumeration porteuse de l'état

> Une énumération ne suffit pas à capturer la richesse des états métier.
{: .prompt-tip}

L’utilisation d’un enum plat (ex. `status ENUM('PENDING','PAID','CANCELLED','REFUNDED')`) impose globalement d'ajouter des champs optionnels pour chaque état (ex. `cancel_reason`, `refunded_at`).  

- Le caractère optionnel est directement lié à l’état, ce qui viole l’axiome des **optionnels non-décisionnels**.
- Certains champs deviennent obligatoires selon l’état, mais cette contrainte est rarement exprimée dans le schéma, menant à des données invalides.
- Des attributs peuvent être partagés entre plusieurs états, ajoutant de la confusion et des effets de bord difficiles à identifier.

Le code applicatif devient le seul responsable de maintenir la cohérence entre `status` et les champs associés, ce qui favorise les bugs et la dette technique par l'introduction de la nullité et des règles implicites.

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  status ENUM('PENDING','PAID','CANCELLED','REFUNDED') NOT NULL,
  cancel_reason TEXT,
  refunded_at TIMESTAMPTZ,
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  modified_at TIMESTAMPTZ DEFAULT now()
);
```

Dans cet exemple :

- `cancel_reason` n’a de sens que pour CANCELLED,
- `refunded_at` uniquement pour REFUNDED,
- `paid_at` pour PAID.
- `modified_at` est partagé, mais n’a pas de signification claire selon l’état.

La moitié des colonnes deviennent donc inutiles ou `NULL` selon la valeur de `status`.
Au fil du temps, de nouveaux états apparaissent (`RETURNED`, `FAILED`, `PARTIALLY_REFUNDED`…), chacun amenant de nouvelles colonnes optionnelles.

> Le code applicatif doit alors gérer une matrice croissante de conditions et d'assertions pour maintenir la cohérence entre `status` et les champs associés.
{: .prompt-warning }

La colonne `modified_at` n'est plus l'unique source de vérité selon l'état:

- Pour `PENDING`, c’est `created_at`.
- Pour `PAID`, c’est `paid_at`.
- Pour `CANCELLED`, c’est `modified_at`.
- Pour `REFUNDED`, c’est `refunded_at`.

## Immutabilité

> Quand c'est possible, privilégier les objets immuables pour représenter les états métier.
{: .prompt-tip}

Quand le domaine le permet, les objets représentant des états métier doivent être traités comme immuables. Une fois créés, ils ne doivent pas être modifiés, mais plutôt remplacés par de nouveaux objets représentant les états suivants.

Cependant, dans certains cas, les champs relatifs à un état peuvent nécessiter des mises à jour. Dans ces situations, il est crucial de documenter clairement les règles de modification et il faut s'assurer que ces mutations n'altèrent pas l'intégrité de l'état.

Exemple :

Un champ optionnel `delivery_notes` peut être ajouté à un état `SHIPPED` pour capturer des informations supplémentaires sur la livraison. Tant que ce champ n'affecte pas la nature de l'état `SHIPPED`, il peut être mis à jour sans violer le principe d'immuabilité de l'état lui-même.

> Le principe de l'immuabilité ne doit pas conduire à créer un ADT pour chaque petite modification. Il est important de distinguer entre les changements qui affectent l'état métier et ceux qui sont simplement des mises à jour d'attributs non décisionnels.
{: .prompt-warning }

## ADT dans les langages de la vie réelle

Venant du monde des langages de programmation fonctionnels, les ADT se retrouvent sous différentes formes dans les langages courants, ce concept n'est plus réservé aux langages exotiques.

### Types discriminés en TypeScript

```typescript
type Order =
  | { type: 'PENDING'; createdAt: Date }
  | { type: 'PAID'; paidAt: Date; amount: number }
  | { type: 'CANCELLED'; cancelledAt: Date; reason: string }
  | { type: 'REFUNDED'; refundedAt: Date; amount: number };
```

{% include embed/youtube.html id='A6pFGessKZM' %}

### Sealed classes en Java

```java
sealed interface Order permits Pending, Paid, Cancelled, Refunded {}
record Pending(LocalDateTime createdAt) implements Order {}
record Paid(LocalDateTime paidAt, BigDecimal amount) implements Order {}
record Cancelled(LocalDateTime cancelledAt, String reason) implements Order {}
record Refunded(LocalDateTime refundedAt, BigDecimal amount) implements Order {}
```

{% include embed/youtube.html id='8bvo5yj-5W0' %}

### Articles en relation

- Origine du besoin et symptômes du modèle data‑first : [Introduction SDD](/2025/11/01/sdd-intro/)
- Construction relationnelle complète : [Article principal](/2025/11/01/sdd/)
