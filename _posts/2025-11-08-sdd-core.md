---
layout: post
lang: fr
title: "Modéliser les états"
description: "Principes de modélisation des états métier dérivables et transitions explicites (State‑Driven Design)."
date: 2025-11-08 00:00:00 +0100
last_modified_at: 2025-11-08 11:15:00 +0100
author: ab
categories: [Architecture]
tags: [sdd, state-driven design, data modeling, domain-driven design, ddd, sql, architecture]
permalink: /2025/11/08/sdd-core/
page_id: article-sdd-core
nav_section: articles
toc: true
---

{:.lead}
Ce document condense les principes structurants pour modéliser des **états métier** stables et dérivables, avec des **transitions explicites** et une **traçabilité append‑only**. Il prolonge l'introduction publiée dans [l’article introductif](/2025/11/01/sdd-intro/) et complète la vue d’ensemble présentée dans [Des tables fourre-tout aux relations fonctionnelles](/2025/11/01/sdd/).

> **Série SDD** : [Intro](/2025/11/01/sdd-intro/) • [Fondations](/2025/11/01/sdd/) • [Axiomes](/2025/11/08/sdd-core/) • [SQL E‑commerce](/2025/11/02/sdd-solves/)

## ADT (types algébriques de données) : la brique de base

Un **ADT** (Algebraic Data Type) est une structure de données définie par une **somme de variantes** (types disjoints) où chaque variante peut porter ses propres attributs (produit de champs).  

Les ADT sont courants en programmation fonctionnelle (Haskell, OCaml, F#) et se rapprochent des **types discriminés** ou **union types** dans des [les languages de la vue réelle](#adt-dans-les-langages-de-la-vie-réelle).

> Dans la grande majorité des cas, un objet métier peut être modélisé comme un ADT d’états, chaque état représentant une *variante* de l’objet avec ses attributs spécifiques.
{:.prompt-tip}

## Axiomes cœur (sémantique)

1. **Mono domaine** – Un schéma d’état ne porte qu’un métier (un seul ADT). Mélanger des métiers viole le modèle.
2. **État dérivable** – Un état est entièrement déterminé par ses données. Aucun “status magique” n’est nécessaire pour le déduire.
3. **Optionnels non-décisionnels** – Une valeur optionnelle n’altère jamais l’appartenance à l’état ; elle n’enrichit que sa description.
4. **Temporalité explicite** – Tout état existe sur un intervalle (implicite via le journal ou explicite via [from,to)). Sans temporalité → ce n’est pas un état, mais une caractéristique.
5. **Transitions premières classes** – Un changement d’état est une transition explicite, pas une mutation en place.
6. **Unicité d’état actif** – À un instant t, pour une entité donnée et un domaine donné, un seul état peut être actif.
7. **Append-only** – L’historique ne se réécrit pas : on clôt l’ancien état, on insère le nouveau.
8. **Variants porteurs** – Les variantes de l’ADT portent leurs attributs propres et leurs invariants. L’énum “à champs identiques” est un [anti‑pattern](#enumeration-porteuse-de-létat).
9. **Reconstructibilité** – À partir de la donnée stockée, on peut rejouer l’histoire des états et retrouver la vue à une date passée.
10. **Composition par lecture** – Les vues “globales” se composent (projections/joins) ; on ne fusionne pas les domaines dans une même table.

## Anti patterns courants

### Booléens décisionnels

L’usage de booléens pour représenter des états métier est un anti‑pattern fréquent. Un booléen `is_paid` peut sembler simple, mais il ne capture pas la complexité des états possibles (ex. `PENDING`, `PAID`, `CANCELLED`, `REFUNDED`). Il conduit souvent un état ambigu voir incohérent.

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  is_paid BOOLEAN DEFAULT false,
  is_cancelled BOOLEAN DEFAULT false,
  is_refunded BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  modified_at TIMESTAMPTZ DEFAULT now()
);
```

Dans cet exemple :

| Cas | Valeurs possibles | Interprétation |
|-----|-------------------|----------------|
| Ambigu | is_paid = true, is_cancelled = true | Commande payée puis annulée ? |
| Ambigu | is_paid = false, is_refunded = true | Commande remboursée sans paiement ? |
| Incohérent | is_paid = true, is_cancelled = true, is_refunded = true | Commande payée, annulée et remboursée ? |

Ces cas illustrent l’ambiguïté combinatoire : plusieurs flags vrais produisent des combinaisons impossibles à interpréter. Les autres ambiguïtés (temporelle, granularité, domaine croisé) sont détaillées ci‑dessous.

Les booléens de statut simplifient excessivement des situations riches. Quatre ambiguïtés dominantes expliquent la dérive :

1. Combinatoire – Plusieurs flags vrais (`is_paid` + `is_cancelled` + `is_refunded`) forment des combinaisons que le schéma ne sait pas interpréter ni interdire (cf. tableau ci‑dessus).
1. Temporelle – L’ordre des faits est perdu : `is_paid = true` et `is_cancelled = true` ne disent pas lequel est survenu en premier, empêchant toute logique métier fiable.
1. Granularité – Un flag ne porte ni montants, ni raisons, ni distinctions (autorisé vs capturé, partiel vs total). L’état réel a besoin d’attributs structurés.
1. Domaine croisé – Des flags de domaines différents (`is_paid`, `is_shipped`, `is_delivered`) se retrouvent sur la même table ; on autorise implicitement des états illégaux (livré sans payé) faute d’invariants exprimés.

Conséquence : la table devient une matrice implicite d’états difficile à valider et à rejouer. Remplacer les booléens par un **journal d’événements** ou un **ADT de variantes** rend l’historique explicite, encode les attributs indispensables et formalise les transitions autorisées.

### Enumeration porteuse de l'état

L’utilisation d’un enum plat (ex. `status ENUM('PENDING','PAID','CANCELLED','REFUNDED')`) impose globalement d'ajouter des champs optionnels pour chaque état (ex. `cancel_reason`, `refunded_at`).  

- Le caractère optionnel est directement lié à l’état, ce qui viole l’axiome des **optionnels non-décisionnels**.
- Certains champs deviennent obligatoires selon l’état, mais cette contrainte est rarement exprimée dans le schéma, menant à des données invalides.
- Des attributs peuvent être partagés entre plusieurs états, ajoutant de la confusion et des effets de bord difficiles à identifier.

Le code applicatif devient le seul responsable de maintenir la cohérence entre `status` et les champs associés, ce qui favorise les bugs et la dette technique par l'introduction de la nullité et des règles implicites.

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  status ENUM('PENDING','PAID','CANCELLED','REFUNDED') NOT NULL,
  cancel_reason TEXT,
  refunded_at TIMESTAMPTZ,
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  modified_at TIMESTAMPTZ DEFAULT now()
);
```

Dans cet exemple :

- `cancel_reason` n’a de sens que pour CANCELLED,
- `refunded_at` uniquement pour REFUNDED,
- `paid_at` pour PAID.
- `modified_at` est partagé, mais n’a pas de signification claire selon l’état.

La moitié des colonnes deviennent donc inutiles ou `NULL` selon la valeur de `status`.
Au fil du temps, de nouveaux états apparaissent (`RETURNED`, `FAILED`, `PARTIALLY_REFUNDED`…), chacun amenant de nouvelles colonnes optionnelles.

> Le code applicatif doit alors gérer une matrice croissante de conditions et d'assertions pour maintenir la cohérence entre `status` et les champs associés.
{: .prompt-warning }

La colonne `modified_at` n'est plus l'unique source de vérité selon l'état:

- Pour `PENDING`, c’est `created_at`.
- Pour `PAID`, c’est `paid_at`.
- Pour `CANCELLED`, c’est `modified_at`.
- Pour `REFUNDED`, c’est `refunded_at`.

> Le code applicatif doit alors deviner la bonne source de vérité selon l’état, multipliant les conditions et les risques d’erreurs.
{: .prompt-warning }

## ADT dans les langages de la vie réelle

Venant du monde des langages de programmation fonctionnels, les ADT se retrouvent sous différentes formes dans les langages courants, ce concept n'est plus réservé aux langages exotiques.

### Types discriminés en TypeScript

```typescript
type Order =
  | { type: 'PENDING'; createdAt: Date }
  | { type: 'PAID'; paidAt: Date; amount: number }
  | { type: 'CANCELLED'; cancelledAt: Date; reason: string }
  | { type: 'REFUNDED'; refundedAt: Date; amount: number };
```

### Sealed classes en Java

```java
sealed interface Order permits Pending, Paid, Cancelled, Refunded {}
record Pending(LocalDateTime createdAt) implements Order {}
record Paid(LocalDateTime paidAt, BigDecimal amount) implements Order {}
record Cancelled(LocalDateTime cancelledAt, String reason) implements Order {}
record Refunded(LocalDateTime refundedAt, BigDecimal amount) implements Order {}
```

### Articles en relation

- Origine du besoin et symptômes du modèle data‑first : [Introduction SDD](/2025/11/01/sdd-intro/)
- Construction relationnelle complète : [Article principal](/2025/11/01/sdd/)
