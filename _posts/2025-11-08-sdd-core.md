---
layout: post
lang: fr
title: "Modéliser les états"
description: "Principes de modélisation des objets métier et de leurs états via des types union."
date: 2025-11-08 00:00:00 +0100
last_modified_at: 2025-11-08 21:30:00 +0100
author: ab
categories: [Architecture]
tags: [sdd, state-driven design, data modeling, domain-driven design, ddd, sql, architecture]
permalink: /2025/11/08/sdd-core/
page_id: article-sdd-core
nav_section: articles
toc: true
---

{:.lead}
Nous allons détailler les principes structurants pour modéliser des **états métier** consistants et évolutifs, avec des **transitions explicites** et sans perte de **traçabilité**.

## ADT (type union) : la brique de base

> Ici, ADT = Algebraic Data Type, utilisé comme un type union (union discriminée) : un seul état possible à la fois, et chaque état a ses propres champs.
{:.prompt-tip}

Un type union est un type « ou-bien » composé de variantes exclusives (les états).  
En pratique : un enum personnalisable où chaque valeur peut embarquer ses propres champs.

* Résultat d'une opération `Success | Failure` avec des champs spécifiques à chaque cas.
* État d'une commande `Pending | Paid | Cancelled | Refunded`, chaque état ayant ses propres attributs.

Les types union sont courants en programmation fonctionnelle (Haskell, OCaml, F#) et se rapprochent des **types discriminés** ou **union types** dans des [les languages de la vie réelle](#adt-dans-les-langages-de-la-vie-réelle).

## Principes fondamentaux

> Ces principes posent la base d’une modélisation des états métiers: fermée sur la cardinalité mais ouverte sur l'enrichissement des caractéristiques, suivant le modèle open / closed des principes SOLID.
{: .prompt-tip}

### Relation domaine – état

1. **Mono-domaine** – Un schéma d’état ne porte qu’un métier (un seul ADT).
1. **Exhaustivité** – Le modèle couvre tous les états métier possibles, sans lacune ni ambiguïté.
1. **Unicité** – À un instant t, pour une entité donnée et un domaine donné, un seul état peut être actif.
1. **État dérivable** – L’état se déduit entièrement des données. Aucun “status magique” n’est nécessaire.
1. **Temporalité** – Tout état s’inscrit dans un intervalle de temps. Sans temporalité, il s’agit d’une simple caractéristique, pas d’un état.
1. **Transitions explicites** – Tout changement d’état résulte de la création d’un nouvel état via une transition métier identifiée.

### Stabilité de la modélisation

1. **Les états sont fermés** – L'ajout de nouveaux traduit un changement profond du métier, pas une simple évolution technique.
1. **Les attributs des états ouverts** – Les champs d’un état peuvent être enrichis sans altérer la cohérence du modèle.
1. **Optionnels non-décisionnels** – Une valeur optionnelle n’altère jamais l’appartenance à l’état: elle n’enrichit que sa description.
1. **Invariants localisés** – Chaque état porte ses propres règles de validité.
Les contraintes sont locales, pas globales.
1. **Historisation** – L’historique des états est conservé intégralement. On clôt l’ancien état et on insère le nouveau, sans jamais modifier ou supprimer un passé.

> En accordant aux états du domaine une place centrale et prépondérante, on renforce intrinsèquement la lisibilité et la cohérence des données métier, tout en facilitant l’évolution par itérations successives.
{: .prompt-info}

## Anti patterns

On retrouve des booléens et des énumérations porteuses d’état dans la majorité des schémas relationnels, souvent à l’origine de problèmes de maintenabilité et d’évolution. Nous détaillons ci‑dessous deux anti‑patterns courants.

### Booléens décisionnels

> Les booléens décisionnels mènent rapidement à des combinaisons ambiguës ou incohérentes.
{: .prompt-tip}

L’usage de booléens pour représenter des états métier est un anti‑pattern fréquent. Un booléen `is_paid` peut sembler simple, mais il ne capture pas la complexité des états possibles (ex. `PENDING`, `PAID`, `CANCELLED`, `REFUNDED`). Il conduit souvent un état ambigu voir incohérent.

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  is_paid BOOLEAN DEFAULT false,
  is_cancelled BOOLEAN DEFAULT false,
  is_refunded BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  modified_at TIMESTAMPTZ DEFAULT now()
);
```

Dans cet exemple :

| Cas | Valeurs possibles | Interprétation |
|-----|-------------------|----------------|
| Ambigu | is_paid = true, is_cancelled = true | Commande payée puis annulée ? |
| Ambigu | is_paid = false, is_refunded = true | Commande remboursée sans paiement ? |
| Incohérent | is_paid = true, is_cancelled = true, is_refunded = true | Commande payée, annulée et remboursée ? |

Ces cas illustrent l’ambiguïté combinatoire : plusieurs flags vrais produisent des combinaisons impossibles à interpréter. Les autres ambiguïtés (temporelle, granularité, domaine croisé) sont détaillées ci‑dessous.

Les booléens de statut simplifient excessivement des situations riches. Quatre ambiguïtés dominantes expliquent la dérive :

1. Combinatoire – Plusieurs flags vrais (`is_paid` + `is_cancelled` + `is_refunded`) forment des combinaisons que le schéma ne sait pas interpréter ni interdire (cf. tableau ci‑dessus).
1. Temporelle – L’ordre des faits est perdu : `is_paid = true` et `is_cancelled = true` ne disent pas lequel est survenu en premier, empêchant toute logique métier fiable.
1. Granularité – Un flag ne porte ni montants, ni raisons, ni distinctions (autorisé vs capturé, partiel vs total). L’état réel a besoin d’attributs structurés.
1. Domaine croisé – Des flags de domaines différents (`is_paid`, `is_shipped`, `is_delivered`) se retrouvent sur la même table ; on autorise implicitement des états illégaux (livré sans payé) faute d’invariants exprimés.

> La table devient une matrice implicite d’états difficile à valider et à rejouer. Remplacer les booléens par un **journal d’événements** ou un **ADT de variantes** rend l’historique explicite, encode les attributs indispensables et formalise les transitions autorisées.
{: .prompt-warning }

### Enumeration porteuse d'état

> Une énumération ne suffit pas à capturer la richesse des états métier.
{: .prompt-tip}

L’utilisation d’un enum plat (ex. `status ENUM('PENDING','PAID','CANCELLED','REFUNDED')`) impose globalement d'ajouter des champs optionnels pour chaque état (ex. `cancel_reason`, `refunded_at`).  

* Le caractère optionnel est directement lié à l’état, ce qui viole l’axiome des **optionnels non-décisionnels**.
* Certains champs deviennent obligatoires selon l’état, mais cette contrainte est rarement exprimée dans le schéma, menant à des données invalides.
* Des attributs peuvent être partagés entre plusieurs états, ajoutant de la confusion et des effets de bord difficiles à identifier.

Le code applicatif devient le seul responsable de maintenir la cohérence entre `status` et les champs associés, ce qui favorise les bugs et la dette technique par l'introduction de la nullité et des règles implicites.

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  status ENUM('PENDING','PAID','CANCELLED','REFUNDED') NOT NULL,
  cancel_reason TEXT,
  refunded_at TIMESTAMPTZ,
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  modified_at TIMESTAMPTZ DEFAULT now()
);
```

Dans cet exemple :

* `cancel_reason` n’a de sens que pour CANCELLED,
* `refunded_at` uniquement pour REFUNDED,
* `paid_at` pour PAID.
* `modified_at` est partagé, mais n’a pas de signification claire selon l’état.

La moitié des colonnes deviennent donc inutiles ou `NULL` selon la valeur de `status`.
Au fil du temps, de nouveaux états apparaissent (`RETURNED`, `FAILED`, `PARTIALLY_REFUNDED`…), chacun amenant de nouvelles colonnes optionnelles.

La colonne `modified_at` n'est plus l'unique source de vérité selon l'état:

* Pour `PENDING`, c’est `created_at`.
* Pour `PAID`, c’est `paid_at`.
* Pour `CANCELLED`, c’est `modified_at`.
* Pour `REFUNDED`, c’est `refunded_at`.

> Le code applicatif doit alors gérer une matrice croissante de conditions et d'assertions pour maintenir la cohérence entre `status` et les champs associés.
{: .prompt-warning }

## Immutabilité

> Quand c'est possible, privilégier les objets immuables pour représenter les états métier.
{: .prompt-tip}

Quand le domaine le permet, les objets représentant des états métier doivent être traités comme immuables. Une fois créés, ils ne doivent pas être modifiés, mais plutôt remplacés par de nouveaux objets représentant les états suivants.

Cependant, dans certains cas, les champs relatifs à un état peuvent nécessiter des mises à jour. Dans ces situations, il est crucial de documenter clairement les règles de modification et il faut s'assurer que ces mutations n'altèrent pas l'intégrité de l'état.

Exemple :

Un champ optionnel `delivery_notes` peut être ajouté à un état `SHIPPED` pour capturer des informations supplémentaires sur la livraison. Tant que ce champ n'affecte pas la nature de l'état `SHIPPED`, il peut être mis à jour sans violer le principe d'immuabilité de l'état lui-même.

> Le principe de l'immuabilité ne doit pas conduire à créer un ADT pour chaque petite modification. Il est important de distinguer entre les changements qui affectent l'état métier et ceux qui sont simplement des mises à jour d'attributs non décisionnels.
{: .prompt-warning }

## ADT dans les langages de la vie réelle

Venant du monde des langages de programmation fonctionnels, les ADT se retrouvent sous différentes formes dans les langages courants, ce concept n'est plus réservé aux langages exotiques.

### Types discriminés en TypeScript

```typescript
type Order =
  | { type: 'PENDING'; createdAt: Date }
  | { type: 'PAID'; paidAt: Date; amount: number }
  | { type: 'CANCELLED'; cancelledAt: Date; reason: string }
  | { type: 'REFUNDED'; refundedAt: Date; amount: number };
```

> Présentation sur l'utilisation des types lors de la modélisation du métier avec TypeScript.

{% include embed/youtube.html id='A6pFGessKZM' %}

### Sealed classes en Java

```java
sealed interface Order permits Pending, Paid, Cancelled, Refunded {}
record Pending(LocalDateTime createdAt) implements Order {}
record Paid(LocalDateTime paidAt, BigDecimal amount) implements Order {}
record Cancelled(LocalDateTime cancelledAt, String reason) implements Order {}
record Refunded(LocalDateTime refundedAt, BigDecimal amount) implements Order {}
```

> Présentation du pattern matching et du Data Driven Design en Java.

{% include embed/youtube.html id='8bvo5yj-5W0' %}

### Articles en relation

* Origine du besoin et symptômes du modèle data‑first : [Introduction SDD](/2025/11/01/sdd-intro/)
* Construction relationnelle complète : [Article principal](/2025/11/01/sdd/)
